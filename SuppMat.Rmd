---
title: "Master document, may become the supp mat if we push this approach of R markdown'ing everything"
author: "Anderson et al"
date: "April 20, 2018"
output: pdf_document
---

<!--Install the correct reumannplatz version from github, i.e., the one current on 2018 04 20, tagged
in git with AndersonDeer-->
```{r rp_install}
library(devtools)
devtools::install_github(repo="reumandc/reumannplatz",ref="AndersonDeer")
```

<!--Libraries. Should use checkpoint, but having trouble using reumannplatz from github and checkpoint
at the same time. To be solved later if possible.-->
```{r libraries}
library(reshape2)
library(tidyr)
library(plyr)
library(tools)
library(fields)
library(Reumannplatz)
library(shape)
```

<!--Flags controlling the run and other setup-->
```{r setup}
#which density to use ("dnr" for original estimates, "tom" for your own calculations)
dens.flag<-"dnr"

#what is the earliest year you want? (hunting only: 1960; abundance: 1981; DVC: 1987; Traffic: 1988, Hunters: 1992)
minyear<-1981

#what is the last year you want? (max is 2016)
maxyear<-2016
  
#normalize the data ("norm" for Box-Cox, "detr" for linearly detrend, or "none")
##Code currently work using the "none" option; the normalization steps happen 
##individually with each analysis step (e.g. see line 15 in "DeerAbundance.R" file), 
##because of the conflicting data lengths and dimensions. 
detr.flag<-"none"

#set spatial scale flag for data generation ("usda", "county" or "both")
scale.flag<-"both"

#***DAN: Not sure what this is, Tom, if this is not necessary should be deleted? 
#calculate how many missing climate values there were (don't need to run anymore)
samplesize.flag<-"n"

#set number of surrogates to use for spatial coherence
nsurrogs<-10000

#a function needed for caching
source("Code/mtime.R") 
```

<!--***DAN: Rum time is sufficiently long that we should probably use caching, but
that will require a good understanding of dependencies of everything. I have begun.
Other reasons to use cacheing include it will enforce a clearer specification of
dependencies between chunks.-->

<!--Clean the population data-->
```{r clean_pop_data, cache=T,cache.extra=list(dens.flag,minyear,maxyear,detr.flag,mtime("Code/wi.deer.cleandata.R"),mtime("Data/State_Kill.csv"),mtime("Data/County_KillTotal.csv"),mtime("Data/County_Kill_BuckOnly.csv"),mtime("Data/County_Kill_DoeOnly.csv"),mtime("Data/County_KillGunBuck.csv"),mtime("Data/County_KillGunDoe.csv"),mtime("Data/County_KillBowBuck.csv"),mtime("Data/County_KillBowDoe.csv"),mtime("Data/WI_Cty_CentroidDD.csv"),mtime("Data/DOT_Accidents1987_2016.csv"),mtime("Data/Adj_DOT_Accidents1987_2016.csv"),mtime("Data/OpeningDay.csv"),mtime("Data/CornHarvest.csv"),mtime("Data/WI_USDA_Sections.csv"),mtime("Data/USDA_centroids.csv"),mtime("Data/Cty_Traffic.csv"),mtime("Data/DMU_DeerAbundance1981_2013.csv"),mtime("Data/DMU_DeerDensity1981_2013.csv"),mtime("Data/DMU_HunterAbundance1975_2013.csv"),mtime("Data/DMU_HunterDensity1975_2013.csv"),mtime("Data/hunterdens1416.csv"),mtime("Data/hunterabun1416.csv"),mtime("Data/Cty_Abun_2014_2016.csv"),mtime("Data/permit_issued1970_2013.csv"))}
#Clean population data: end result are two lists of matrices called "cty.list" and "usda.list"
system.time(source("Code/wi.deer.cleandata.R"))
  #list of files generated by wi.deer.cleandata.R:
    #scale.flag == "usda": usda.list, includes data on abundance, kill data, crops, DVCs and traffic
    #scale.flag == "county": cty.list, includes data on abundance, kill data, crops, DVCs and traffic
```

<!--Clean the climate data-->
```{r clean_clim_data, cache=T, cache.extra=list(minyear,maxyear,detr.flag,scale.flag,mtime("Code/wi_climate.R"),mtime("Data/noaa_latlongUpd.csv"),mtime("Data/WI_USDA_Sections.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set1.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set2.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set3.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set4.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set5.csv"),mtime("Data/Cty_NOAA_Temp1981_2015_set6.csv"),mtime("Data/Cty_NOAA_Temp2016_2017.csv"),mtime("Data/Cty_NOAA_Precip1981_1985.csv"),mtime("Data/Cty_NOAA_Precip1986_1991.csv"),mtime("Data/Cty_NOAA_Precip1992_1997.csv"),mtime("Data/Cty_NOAA_Precip1998_2003.csv"),mtime("Data/Cty_NOAA_Precip2004_2009.csv"),mtime("Data/Cty_NOAA_Precip2010_2015.csv"),mtime("Data/Cty_NOAA_Precip2016_2017.csv"),mtime("Data/climate_indices.csv"),mtime("Data/mei.csv"),mtime("Data/pdo.csv"),mtime("Data/npi.csv"),mtime("Data/ENSO.csv"))}
system.time(source("Code/wi_climate.R"))
#list of files generated by wi_climate.R:
  #scale.flag == "usda": wsi.usda.mat,hunt.clim.usda, winter.clim.usda,nao.mat,pdo.mat,mei.mat,winter.nao,winter.pdo,winter.mei
  #scale.flag == "county": wsi.mat,wsi.matN,hunt.clim,winter.clim,nao.mat,pdo.mat,mei.mat,winter.nao,winter.pdo,winter.mei
  #large climate indices are the same values (nao,mei,pdo), just replicated into different dimensions to match scale.flag
```

<!--County analysis-->
<!--***DAN: DANGER this list of dependencies not complete, need to fill in!-->
```{r county_analysis, cache=T, cache.extra=list(mtime("Code/DeerAbundance.R"))}
#Run analysis on deer abundance and DVCs using county data
set.seed(101)
system.time(source("Code/DeerAbundance.R"))
```

<!--***DAN: You want this whole code suite to be *exactly* reproducible, so any random bits
need to have the seed set first. Check for that.-->

<!--District analysis-->
<!--***DAN: DANGER this list of dependencies not complete, need to fill in!-->
```{r district_analysis, cache=T, cache.extra=list(mtime("Code/DeerAbundanceUSDA.R"))}
#Run analysis on deer abundance and DVCs using USDA district data
set.seed(201)
system.time(source("Code/DeerAbundanceUSDA.R"))
```

<!--Make plots-->
<!--***DAN: DANGER this list of dependencies not complete, need to fill in!-->
```{r make_plots, cache=T, cache.extra=list(mtime("Code/deer_plots.R"))}
#generate raw data plots
set.seed(301)
system.time(source("Code/deer_plots.R"))

#***DAN: I got the following warnings when I ran deer_plots.R, we have to get 
#to the bottom of these and make them stop by solving the underlying problem:
#Warning messages:
#  1: In plot.window(...) : "smallplot" is not a graphical parameter
#2: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#3: In title(...) : "smallplot" is not a graphical parameter
#4: In plot.window(...) : "smallplot" is not a graphical parameter
#5: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#6: In title(...) : "smallplot" is not a graphical parameter
#7: In plot.window(...) : "smallplot" is not a graphical parameter
#8: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#9: In title(...) : "smallplot" is not a graphical parameter
#10: In plot.window(...) : "smallplot" is not a graphical parameter
#11: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#12: In title(...) : "smallplot" is not a graphical parameter
#13: In plot.window(...) : "smallplot" is not a graphical parameter
#14: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#15: In title(...) : "smallplot" is not a graphical parameter
#16: In plot.window(...) : "smallplot" is not a graphical parameter
#17: In plot.xy(xy, type, ...) : "smallplot" is not a graphical parameter
#18: In title(...) : "smallplot" is not a graphical parameter

#***DAN: Fig 1 does not appear, the code for it needs to be put in
```

# Materials and methods

## Data and pre-processing

<!--***DAN: I inserted a comment in each place that needs to be made 
or may need to be made an automatic link to a reference, table, figure, 
or R-produced value. As these are done, the comment can be deleted,
as can the non-automatic text that the automatic link should replace.
But leave the non-automatic text until you do a knit to make sure you
get the same thing.-->

<!--***DAN: demo of ordinary text-->
We obtained deer abundance estimates from the Wisconsin Department of 
Natural Resources (WIDNR) spanning a 36<!--***DAN-->-yr period 
(1981–2016<!--***DAN-->; Fig. S1<!--***DAN-->). 
From 1981–2013<!--***DAN-->, deer abundance was estimated for deer management units 
(DMUs, N = 101–139<!--***DAN--> depending on the year). For most years and DMUs, 
abundance was estimated using a sex-age-kill (SAK) model, with aerial surveys or 
accounting models used for a smaller number of years and DMUs (1)<!--***DAN-->. 
In $2014$, DMU boundaries were changed to match the administrative level of 
county (N = 72<!--***DAN-->). Because of this, and because other 
spatial variables (e.g., DVCs, climate) were gathered at the county level, 
we transformed the 1981–2013<!--***DAN--> abundance estimates for DMUs 
into county-level estimates. To do so, we first calculated the areas 
of intersection between DMU and county boundaries for each year (as 
DMU boundaries changed yearly), using the ‘intersect’ function in 
Arc GIS 10.3 (ESRI, Redlands, CA). We then calculated deer abundance 
for each intersection area by multiplying the amount of deer habitat in 
each intersection area by the WIDNR density estimate of deer for the DMU 
that the intersection fell within. Deer habitat was considered to comprise 
areas of permanent cover (e.g., forests) that were $>4$ ha in size. DMU deer 
densities were calculated by dividing the estimated abundance for the DMU 
by the amount of deer habitat within the DMU (1)<!--***DAN-->. This procedure 
assumes approximately spatially uniform densities of deer within deer 
habitat across each DMU. The abundance for a county was the sum of 
the estimated abundances of the county’s intersections with the DMUs. 
We dropped one county (Menominee) due to incomplete data for most 
variables, leaving 71<!--***DAN--> counties for statistical analysis.

<!--***DAN: Much text skipped for now-->

## Analysis

We performed all analyses described below and in the main text 
at three spatial scales: counties (N = 44–71<!--***DAN--> depending on 
the variables involved; mean county 
area $\pm$ SD = 2017<!--***DAN--> $\pm$ 799<!--***DAN--> $\text{km}^2$), 
United States Department of Agriculture (USDA) districts ($N = 9$; mean 
district area $\pm$ SD = 16138<!--***DAN--> $\pm$ 799<!--***DAN--> $\text{km}^2$), 
and statewide (Fig. S2<!--***DAN-->). Analyses at three spatial scales 
were performed because the SAK model used by the WIDNR to estimate deer 
abundance for each management unit has been criticized as less accurate 
at smaller spatial scales (5)<!--***DAN-->. However, the bias in abundance 
estimates previously reported may overestimated, as more recent analyses 
suggest the uncertainty in SAK estimates is substantially less 
($\pm 20\%$ error rates; WIDNR, personal communication). Regardless, 
to ensure our results were not biased by spatial extent, we analyzed 
synchrony at multiple spatial extents. USDA districts were the sum or 
average of county-level variables, as the two scales had nested boundaries, 
roughly equating to $6$ to $8$ counties per district (Fig. S2<!--***DAN-->). 
Statewide analysis used state total or average time series for each 
variable. In general, the patterns of significance and phase relationships 
we observed remained unchanged in their main substance using data 
aggregated to larger spatial scales (Table S4<!--***DAN-->, S5<!--***DAN-->; 
Fig. S6<!--***DAN-->), suggesting the results for counties are not 
meaningfully biased by any possible inaccuracies in SAK abundance estimation 
procedures at the county level.

<!--***DAN: Much text skipped for now-->

# Supplementary text

## USDA district results

## Statewide results

# Supplementary figures

\begin{figure}[!h]
\includegraphics[width=\textwidth]{Results/FigS1.png}
\caption{Raw time series of (A) deer abundance, (B) deer-vehicle collisions, 
(C) average winter ($\text{Dec}_{t-1}$ to $\text{Mar}_t$) snow depth, and 
(D) winter climate indices (Multivariate El Ni\~no Southern Oscillation Index, 
MEI; Pacific Decadal Oscillation, PDO), and hunter abundances (E). 
Each line in A-C, E represents a county. Other variables are not shown 
(e.g., Tmin) due to their lack of significance in this 
study.\label{FigS1_timeseries}}
\end{figure}

# Supplementary tables

