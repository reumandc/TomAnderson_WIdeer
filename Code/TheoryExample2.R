#Work on a first theoretical example with AR(1) population dynamics. The noise was 
#a sum of two processes. The first process was generated by putting innovations through
#an AR(2) model in each location. The innovations were white noise with covariance matrix
#with 1s on the diagonal and rho1 in the off diagonal. The second process was white 
#noise with covariance matrix with 1s on the diagonal and rho2 in the off diagonal. 
#
#Also, this file uses the plotted from TheoryExample1.R, as well as some constants
#and other stuff from that script, so needs to be run after that script.

#***the model

#Simulates the model
#
#Args
#N        The number of sampling locations
#rho1     Covariance between locations for the inovations that go into producing 
#           the first environmental noise
#rho2     Covariance between locations used directly for the second environmental
#           noise
#c1
#c2       These two args specify the AR(2) dynamics for first environmental noise
#rhopop   Lag-1 autocorrelation coefficient for population dynamics
#lensim   Length of simulations to do
#numsims  Number of simulations to do
#
#Output - a list with these elements 
#inovations - a lensim by N by numsims array, used for the first environmental noise
#epsilon1 - a lensim by N by numsims array, the first environmental noise
#epsilon2 - a lensim by N by numsims array, the second environmental noise
#epsilon - the sum of epsilon1 and epsilon2
#pops - a lensim by N by numsims array
simmodel2<-function(N,rho1,rho2,c1,c2,rhopop,lensim,numsims)
{
  #**generate the inovations for the generation of the first environmental noise
  
  Sig<-matrix(rho1,N,N)
  diag(Sig)<-1
  inovations<-rmvnorm(3*lensim*numsims,sigma=Sig)
  dim(inovations)<-c(3*lensim,numsims,N)
  inovations<-aperm(inovations,c(1,3,2))
  
  #**now use these to generate the first environmental noise
  
  #now make the noise
  epsilon1<-array(0,dim=c(3*lensim,N,numsims))
  for (counter in 3:(3*lensim))
  {
    epsilon1[counter,,]<-c1*epsilon1[counter-1,,]+
      c2*epsilon1[counter-2,,]+inovations[counter,,]
  }
  
  #throw away transients
  epsilon1<-epsilon1[(dim(epsilon1)[1]-2*lensim+1):(dim(epsilon1)[1]),,]
  inovations<-inovations[(dim(inovations)[1]-2*lensim+1):(dim(inovations)[1]),,]
  
  #**now get the second environmental noise
  
  Sig<-matrix(rho2,N,N)
  diag(Sig)<-1
  epsilon2<-rmvnorm(2*lensim*numsims,sigma=Sig)
  dim(epsilon2)<-c(2*lensim,numsims,N)
  epsilon2<-aperm(epsilon2,c(1,3,2))
  
  #**now add the two environmental noises and use them to simulate pops
  
  #add the noises
  epsilon<-epsilon1+epsilon2
  
  #do the sims  
  pops<-array(0,dim=c(2*lensim,N,numsims))
  for (counter in 2:(2*lensim))
  {
    pops[counter,,]<-rhopop*pops[counter-1,,]+epsilon[counter,,]
  }
  
  #throw away transients  
  pops<-pops[(dim(pops)[1]-lensim+1):(dim(pops)[1]),,]
  epsilon1<-epsilon1[(dim(epsilon1)[1]-lensim+1):(dim(epsilon1)[1]),,]
  epsilon2<-epsilon2[(dim(epsilon2)[1]-lensim+1):(dim(epsilon2)[1]),,]
  inovations<-inovations[(dim(inovations)[1]-lensim+1):(dim(inovations)[1]),,]
  
  return(list(inovations=inovations,
              epsilon1=epsilon1,
              epsilon2=epsilon2,
              epsilon=epsilon1+epsilon2,
              pops=pops))
}

#***do the sims 

#do the sims, case 1
rho1_cs1<-0
rho2_cs1<-0.8
r<-1.5
theta<-pi/2
c1<-(1/r)*2*cos(theta)
c2<-(-1/r^2) 
rhopop<-0.15
numsims<-100
set.seed(101)
simsC1<-simmodel2(N=N,rho1=rho1_cs1,rho2=rho2_cs1,c1=c1,c2=c2,rhopop=rhopop,
                      lensim=lensim,numsims=numsims)

#do the sims, case 2 - have to figure out rho1 for this case first
intgrd<-function(f,c1,c2)
{
  mu<-exp(-2*pi*complex(real=0,imaginary=1)*f)
  return((Mod(1/(1-c1*mu-c2*mu^2)))^2)
}
intres<-integrate(intgrd,-.5,.5,c1=c1,c2=c2)
if (intres$abs.error>1e-4 || intres$message!="OK")
{
  stop("Error location 1: problem with numeric integration")
}
rho1_cs2<-rho2_cs1/intres$value 
rho2_cs2<-0
simsC2<-simmodel2(N=N,rho1=rho1_cs2,rho2=rho2_cs2,c1=c1,c2=c2,rhopop=rhopop,
                      lensim=lensim,numsims=numsims)

#***compute things you need for the figure

#first compute spectra of the noise, loc 1
spec_noise_C1<-my.spec.pgram(simsC1$epsilon[,1,],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
spec_noise_C2<-my.spec.pgram(simsC2$epsilon[,1,],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)

#theory for spectra
x<-spec_noise_C1$freq
mu<-exp(-2*pi*complex(real=0,imaginary=1)*x)
c1<-(1/r)*2*cos(theta)
c2<-(-1/r^2) 
ys_C1_th<-(Mod(1/(1-c1*mu-c2*mu^2)))^2+1
ys_C2_th<-(Mod(1/(1-c1*mu-c2*mu^2)))^2+1

#and cospectra of the noise, locs 1 and 2
hC1<-my.spec.pgram(simsC1$epsilon[,1:2,1],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
hC2<-my.spec.pgram(simsC2$epsilon[,1:2,1],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
xcs_C1<-hC1$freq
xcs_C2<-hC2$freq
ycs_C1<-matrix(NA,length(hC1$pgram[,1,2]),numsims)
ycs_C2<-matrix(NA,length(hC2$pgram[,1,2]),numsims)
ycs_C1[,1]<-Re(hC1$pgram[,1,2])
ycs_C2[,1]<-Re(hC2$pgram[,1,2])
for (counter in 2:numsims)
{
  hC1<-my.spec.pgram(simsC1$epsilon[,1:2,counter],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
  hC2<-my.spec.pgram(simsC2$epsilon[,1:2,counter],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
  ycs_C1[,counter]<-Re(hC1$pgram[,1,2])
  ycs_C2[,counter]<-Re(hC2$pgram[,1,2])
}

#theory for cospectra
ycs_C1_th<-rho1_cs1*(Mod(1/(1-c1*mu-c2*mu^2)))^2+rho2_cs1
ycs_C2_th<-rho1_cs2*(Mod(1/(1-c1*mu-c2*mu^2)))^2+rho2_cs2

#spectra of total pop
totpopsC1<-apply(FUN=sum,X=simsC1$pops,MARGIN=c(1,3))
totpopsC2<-apply(FUN=sum,X=simsC2$pops,MARGIN=c(1,3))
spec_totpops_C1<-my.spec.pgram(totpopsC1,detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
spec_totpops_C2<-my.spec.pgram(totpopsC2,detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)

#theory for the spectra of the tot pop
ytp_C1_th<-(Mod(1/(1-rhopop*mu)))^2*
  ((N^2-N)*(rho1_cs1*(Mod(1/(1-c1*mu-c2*mu^2)))^2+rho2_cs1)+
     N*((Mod(1/(1-c1*mu-c2*mu^2)))^2+1))
ytp_C2_th<-(Mod(1/(1-rhopop*mu)))^2*
  ((N^2-N)*(rho1_cs2*(Mod(1/(1-c1*mu-c2*mu^2)))^2+rho2_cs2)+
     N*((Mod(1/(1-c1*mu-c2*mu^2)))^2+1))

#***make the figure - now just call the function from TheoryExample1.R

makefigtheory(spec_noise_C1,spec_noise_C2,ys_C1_th,ys_C2_th, #noise spec args
              xcs_C1,xcs_C2,ycs_C1,ycs_C2,ycs_C1_th,ycs_C2_th, #noise cospec args
              spec_totpops_C1,spec_totpops_C2,ytp_C1_th,ytp_C2_th, #spec totpop args
              totpopsC1,totpopsC2,251:300, #totpops time series args
              "Results/TheoryExample2.png")

