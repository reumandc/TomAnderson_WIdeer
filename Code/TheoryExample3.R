#Work on a first theoretical example with AR(1) population dynamics. The noise was 
#a sum of two processes. The first process was generated by putting innovations through
#an AR(2) model in each location. The innovations were white noise with covariance matrix
#with 1s on the diagonal and rho1 in the off diagonal. The second process was similar,
#but used a different AR(2) process (producing a different spectral peak), and used
#rho2 instead of rho1.
#
#Also, this file uses the plotted from TheoryExample1.R, as well as some constants
#and other stuff from that script, so needs to be run after that script.

#***the model

#Simulates the model
#
#Args
#N        The number of sampling locations
#rho1     Covariance between locations for the inovations that go into producing 
#           the first environmental noise
#rho2     Covariance between locations for the inovations that go into producing
#           the second environmental noise
#c11
#c12      These two args specify the AR(2) dynamics for first environmental noise
#c21
#c22      These two args specify the AR(2) dynamics for second environmental noise
#rhopop   Lag-1 autocorrelation coefficient for population dynamics
#lensim   Length of simulations to do
#numsims  Number of simulations to do
#
#Output - a list with these elements 
#inovations1 - a lensim by N by numsims array, used for the first environmental noise
#inovations2 - a lensim by N by numsims array, used for the second environmental noise
#epsilon1 - a lensim by N by numsims array, the first environmental noise
#epsilon2 - a lensim by N by numsims array, the second environmental noise
#epsilon - epsilon1+epsilon2
#pops - a lensim by N by numsims array
simmodel3<-function(N,rho1,rho2,c11,c12,c21,c22,rhopop,lensim,numsims)
{
  #**generate the inovations for the generation of the first environmental noise
  
  Sig<-matrix(rho1,N,N)
  diag(Sig)<-1
  inovations1<-rmvnorm(3*lensim*numsims,sigma=Sig)
  dim(inovations1)<-c(3*lensim,numsims,N)
  inovations1<-aperm(inovations1,c(1,3,2))
  
  #**now use these to generate the first environmental noise
  
  #now make the noise
  epsilon1<-array(0,dim=c(3*lensim,N,numsims))
  for (counter in 3:(3*lensim))
  {
    epsilon1[counter,,]<-c11*epsilon1[counter-1,,]+
      c12*epsilon1[counter-2,,]+inovations1[counter,,]
  }
  
  #throw away transients
  epsilon1<-epsilon1[(dim(epsilon1)[1]-2*lensim+1):(dim(epsilon1)[1]),,]
  inovations1<-inovations1[(dim(inovations1)[1]-2*lensim+1):(dim(inovations1)[1]),,]
  
  #**generate the inovations for the generation of the second environmental noise
  
  Sig<-matrix(rho2,N,N)
  diag(Sig)<-1
  inovations2<-rmvnorm(3*lensim*numsims,sigma=Sig)
  dim(inovations2)<-c(3*lensim,numsims,N)
  inovations2<-aperm(inovations2,c(1,3,2))
  
  #**now use these to generate the second environmental noise
  
  #now make the noise
  epsilon2<-array(0,dim=c(3*lensim,N,numsims))
  for (counter in 3:(3*lensim))
  {
    epsilon2[counter,,]<-c21*epsilon2[counter-1,,]+
      c22*epsilon2[counter-2,,]+inovations2[counter,,]
  }
  
  #throw away transients
  epsilon2<-epsilon2[(dim(epsilon2)[1]-2*lensim+1):(dim(epsilon2)[1]),,]
  inovations2<-inovations2[(dim(inovations2)[1]-2*lensim+1):(dim(inovations2)[1]),,]
  
  #**now add the two environmental noises and use them to simulate pops
  
  #add the noises
  epsilon<-epsilon1+epsilon2
  
  #do the sims  
  pops<-array(0,dim=c(2*lensim,N,numsims))
  for (counter in 2:(2*lensim))
  {
    pops[counter,,]<-rhopop*pops[counter-1,,]+epsilon[counter,,]
  }
  
  #throw away transients  
  pops<-pops[(dim(pops)[1]-lensim+1):(dim(pops)[1]),,]
  epsilon1<-epsilon1[(dim(epsilon1)[1]-lensim+1):(dim(epsilon1)[1]),,]
  epsilon2<-epsilon2[(dim(epsilon2)[1]-lensim+1):(dim(epsilon2)[1]),,]
  inovations1<-inovations1[(dim(inovations1)[1]-lensim+1):(dim(inovations1)[1]),,]
  inovations2<-inovations2[(dim(inovations2)[1]-lensim+1):(dim(inovations2)[1]),,]
  
  return(list(inovations1=inovations1,
              inovations2=inovations2,
              epsilon1=epsilon1,
              epsilon2=epsilon2,
              epsilon=epsilon1+epsilon2,
              pops=pops))
}

#***do the sims 

#do the sims, case 1
rho1_cs1<-0.8
rho2_cs1<-0
r1<-1.5
theta1<-pi/3
c11<-(1/r1)*2*cos(theta1)
c12<-(-1/r1^2) 
r2<-1.5
theta2<-2*pi/3
c21<-(1/r2)*2*cos(theta2)
c22<-(-1/r2^2)
rhopop<-0.15
numsims<-100
set.seed(101)
simsC1<-simmodel3(N=N,rho1=rho1_cs1,rho2=rho2_cs1,c11=c11,c12=c12,
                      c21=c21,c22=c22,rhopop=rhopop,
                      lensim=lensim,numsims=numsims)

#do the sims for case 2 - we first have to figure out rho2_cs2 
rho1_cs2<-0
intgrd<-function(f,c1,c2)
{
  mu<-exp(-2*pi*complex(real=0,imaginary=1)*f)
  return((Mod(1/(1-c1*mu-c2*mu^2)))^2)
}
intresnum<-integrate(intgrd,-.5,.5,c1=c11,c2=c12)
intresdenom<-integrate(intgrd,-.5,.5,c1=c21,c2=c22)
if (intresnum$abs.error>1e-4 || intresnum$message!="OK" ||
    intresdenom$abs.error>1e-4 || intresdenom$message!="OK")
{
  stop("Error location 1: problem with numeric integration")
}
rho2_cs2<-rho1_cs1*intresnum$value/intresdenom$value
simsC2<-simmodel3(N=N,rho1=rho1_cs2,rho2=rho2_cs2,c11=c11,c12=c12,
                      c21=c21,c22=c22,rhopop=rhopop,
                      lensim=lensim,numsims=numsims)

#***compute things you need for the figure

#first compute spectra of the noise, loc 1
spec_noise_C1<-my.spec.pgram(simsC1$epsilon[,1,],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
spec_noise_C2<-my.spec.pgram(simsC2$epsilon[,1,],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)

#theory for spectra
x<-spec_noise_C1$freq
mu<-exp(-2*pi*complex(real=0,imaginary=1)*x)
c1<-(1/r)*2*cos(theta)
c2<-(-1/r^2) 
ys_C1_th<-(Mod(1/(1-c11*mu-c12*mu^2)))^2+(Mod(1/(1-c21*mu-c22*mu^2)))^2
ys_C2_th<-(Mod(1/(1-c11*mu-c12*mu^2)))^2+(Mod(1/(1-c21*mu-c22*mu^2)))^2

#and cospectra of the noise, locs 1 and 2
hC1<-my.spec.pgram(simsC1$epsilon[,1:2,1],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
hC2<-my.spec.pgram(simsC2$epsilon[,1:2,1],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
xcs_C1<-hC1$freq
xcs_C2<-hC2$freq
ycs_C1<-matrix(NA,length(hC1$pgram[,1,2]),numsims)
ycs_C2<-matrix(NA,length(hC2$pgram[,1,2]),numsims)
ycs_C1[,1]<-Re(hC1$pgram[,1,2])
ycs_C2[,1]<-Re(hC2$pgram[,1,2])
for (counter in 2:numsims)
{
  hC1<-my.spec.pgram(simsC1$epsilon[,1:2,counter],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
  hC2<-my.spec.pgram(simsC2$epsilon[,1:2,counter],detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
  ycs_C1[,counter]<-Re(hC1$pgram[,1,2])
  ycs_C2[,counter]<-Re(hC2$pgram[,1,2])
}

#theory for cospectra
ycs_C1_th<-rho1_cs1*(Mod(1/(1-c11*mu-c12*mu^2)))^2+rho2_cs1*(Mod(1/(1-c21*mu-c22*mu^2)))^2
ycs_C2_th<-rho1_cs2*(Mod(1/(1-c11*mu-c12*mu^2)))^2+rho2_cs2*(Mod(1/(1-c21*mu-c22*mu^2)))^2

#spectra of total pop
totpopsC1<-apply(FUN=sum,X=simsC1$pops,MARGIN=c(1,3))
totpopsC2<-apply(FUN=sum,X=simsC2$pops,MARGIN=c(1,3))
spec_totpops_C1<-my.spec.pgram(totpopsC1,detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)
spec_totpops_C2<-my.spec.pgram(totpopsC2,detrend=FALSE,taper=0,spans=c(91,71),plot=FALSE)

#theory for the spectra of the tot pop
ytp_C1_th<-(Mod(1/(1-rhopop*mu)))^2*N*((Mod(1/(1-c11*mu-c12*mu^2)))^2+(Mod(1/(1-c21*mu-c22*mu^2)))^2)+
  (Mod(1/(1-rhopop*mu)))^2*(N^2-N)*(rho1_cs1*(Mod(1/(1-c11*mu-c12*mu^2)))^2+rho2_cs1*(Mod(1/(1-c21*mu-c22*mu^2)))^2)
ytp_C2_th<-(Mod(1/(1-rhopop*mu)))^2*N*((Mod(1/(1-c11*mu-c12*mu^2)))^2+(Mod(1/(1-c21*mu-c22*mu^2)))^2)+
  (Mod(1/(1-rhopop*mu)))^2*(N^2-N)*(rho1_cs2*(Mod(1/(1-c11*mu-c12*mu^2)))^2+rho2_cs2*(Mod(1/(1-c21*mu-c22*mu^2)))^2)

#***make the figure - now just call the function from TheoryExample1.R

makefigtheory(spec_noise_C1,spec_noise_C2,ys_C1_th,ys_C2_th, #noise spec args
              xcs_C1,xcs_C2,ycs_C1,ycs_C2,ycs_C1_th,ycs_C2_th, #noise cospec args
              spec_totpops_C1,spec_totpops_C2,ytp_C1_th,ytp_C2_th, #spec totpop args
              totpopsC1,totpopsC2,251:300, #totpops time series args
              "Results/TheoryExample3.png")
